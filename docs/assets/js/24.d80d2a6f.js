(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{417:function(t,n,e){"use strict";e.r(n);var a=e(45),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"loadlibrary注入dll"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#loadlibrary注入dll"}},[t._v("#")]),t._v(" LoadLibrary注入DLL")]),t._v(" "),e("ul",[e("li",[t._v("https://www.youtube.com/watch?v=IBwoVUR1gt8")]),t._v(" "),e("li",[t._v("https://www.youtube.com/watch?v=PZLhlWUmMs0")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('#include <iostream>\n#include <Windows.h>\n#include <TlHelp32.h>\n\nusing namespace std;\n\nDWORD GetPID(const wchar_t* name)\n{\n\tDWORD pid = 0;\n\tHANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnap != INVALID_HANDLE_VALUE)\n\t{\n\t\tPROCESSENTRY32 pe;\n\t\tpe.dwSize = sizeof(pe);\n\t\tif (Process32First(hSnap, &pe))\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (!_wcsicmp(pe.szExeFile, name))\n\t\t\t\t{\n\t\t\t\t\tpid = pe.th32ProcessID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (Process32Next(hSnap, &pe));\n\t\t}\n\t}\n\tCloseHandle(hSnap);\n\treturn pid;\n}\n\nint main()\n{\n\t// 1. 获取游戏进程id\n\t// 2. 获取游戏进程句柄\n\t// 3. 在游戏进程中申请一块虚拟内存\n\t// 4. 将dll路径写入申请的内存中\n\t// 5. 在游戏进程中创建一个线程，调用LoadLibrary函数加载dll\n\t// 6. 清理资源\n\n\tconst char* dllpath = "C:\\\\Users\\\\ajanuw\\\\Desktop\\\\EmptyDll\\\\Release\\\\EmptyDll.dll";\n\tint nSize = strlen(dllpath) + 1;\n\n\tconst wchar_t* name = L"game2.exe";\n\tDWORD pid = 0;\n\twhile (pid == 0)\n\t{\n\t\tpid = GetPID(name);\n\t\tSleep(40);\n\t}\n\tcout << "pid: " << pid << endl;\n\n\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, pid);\n\tif (!hProcess) return 0;\n\n\n\tLPVOID pDLLPathAddr = VirtualAllocEx(hProcess, 0, nSize, \n\t\tMEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n\tcout << "pDLLPathAddr: " << pDLLPathAddr << endl;\n\n\tWriteProcessMemory(hProcess, pDLLPathAddr, dllpath, nSize, 0);\n\n\tHANDLE hThread = CreateRemoteThread(hProcess, 0, 0,\n\t\t(LPTHREAD_START_ROUTINE)LoadLibraryA, pDLLPathAddr,\n\t\t0, 0);\n\n\tcout << "hThread: " << hThread << endl;\n\tWaitForSingleObject(hThread, INFINITE);\n\t\n\tVirtualFreeEx(hProcess, pDLLPathAddr, 0, MEM_RELEASE);\n\tCloseHandle(hThread);\n\tCloseHandle(hProcess);\n\n\tcout << "释放资源完毕" << endl;\n\treturn 0;\n}\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);