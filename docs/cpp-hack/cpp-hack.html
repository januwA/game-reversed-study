<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>记录游戏逆向学习</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="记录游戏逆向学习">
    
    <link rel="preload" href="/game-reversed-study/assets/css/0.styles.69efb434.css" as="style"><link rel="preload" href="/game-reversed-study/assets/js/app.7795f1ac.js" as="script"><link rel="preload" href="/game-reversed-study/assets/js/2.def8a94b.js" as="script"><link rel="preload" href="/game-reversed-study/assets/js/23.0e54e1fa.js" as="script"><link rel="prefetch" href="/game-reversed-study/assets/js/10.61678c4d.js"><link rel="prefetch" href="/game-reversed-study/assets/js/11.e11df86e.js"><link rel="prefetch" href="/game-reversed-study/assets/js/12.dbb96222.js"><link rel="prefetch" href="/game-reversed-study/assets/js/13.76a28acc.js"><link rel="prefetch" href="/game-reversed-study/assets/js/14.8d2d0dfa.js"><link rel="prefetch" href="/game-reversed-study/assets/js/15.2c7e3920.js"><link rel="prefetch" href="/game-reversed-study/assets/js/16.edbca387.js"><link rel="prefetch" href="/game-reversed-study/assets/js/17.b8d35941.js"><link rel="prefetch" href="/game-reversed-study/assets/js/18.be16e38f.js"><link rel="prefetch" href="/game-reversed-study/assets/js/19.07c1d50a.js"><link rel="prefetch" href="/game-reversed-study/assets/js/20.dab070af.js"><link rel="prefetch" href="/game-reversed-study/assets/js/21.429f5eeb.js"><link rel="prefetch" href="/game-reversed-study/assets/js/22.d5140d68.js"><link rel="prefetch" href="/game-reversed-study/assets/js/24.d80d2a6f.js"><link rel="prefetch" href="/game-reversed-study/assets/js/25.6cd5484c.js"><link rel="prefetch" href="/game-reversed-study/assets/js/26.c66d229e.js"><link rel="prefetch" href="/game-reversed-study/assets/js/27.3a16632f.js"><link rel="prefetch" href="/game-reversed-study/assets/js/28.dc691209.js"><link rel="prefetch" href="/game-reversed-study/assets/js/3.0be79f85.js"><link rel="prefetch" href="/game-reversed-study/assets/js/4.62ab1b27.js"><link rel="prefetch" href="/game-reversed-study/assets/js/5.5888c806.js"><link rel="prefetch" href="/game-reversed-study/assets/js/6.878badeb.js"><link rel="prefetch" href="/game-reversed-study/assets/js/7.f0828ebc.js"><link rel="prefetch" href="/game-reversed-study/assets/js/8.494b91e9.js"><link rel="prefetch" href="/game-reversed-study/assets/js/9.cf6beb9c.js">
    <link rel="stylesheet" href="/game-reversed-study/assets/css/0.styles.69efb434.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/game-reversed-study/" class="home-link router-link-active"><!----> <span class="site-name">记录游戏逆向学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/januwA/game-reversed-study" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/januwA/game-reversed-study" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>/</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>AAScript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>cpp-hack</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/game-reversed-study/cpp-hack/cpp-hack.html" aria-current="page" class="active sidebar-link">cpp-hack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#读取值-和写入值" class="sidebar-link">读取值，和写入值</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#类似ce的read-writeintger函数" class="sidebar-link">类似CE的read/writeIntger函数</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#dll" class="sidebar-link">DLL</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#aascript-to-c" class="sidebar-link">AAScript to c++</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#module-scan" class="sidebar-link">module scan</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#c-调用游戏函数" class="sidebar-link">C++调用游戏函数</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#绕行挂钩技术-x86" class="sidebar-link">绕行挂钩技术 x86</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#绕行挂钩技术-x64" class="sidebar-link">绕行挂钩技术 x64</a></li><li class="sidebar-sub-header"><a href="/game-reversed-study/cpp-hack/cpp-hack.html#钩住opengl32-dll-wglswapbuffers函数头" class="sidebar-link">钩住opengl32.dll-&gt;wglSwapBuffers函数头</a></li></ul></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>inject</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>socket</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/game-reversed-study/cpp-hack/内核模式.html" class="sidebar-link">内核模式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>dnspy</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Ghidra</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>LUA</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><ul><li>https://www.youtube.com/watch?v=wiX5LmdD5yk&amp;list=PL2C03D3BB7FAF2EA0&amp;index=2</li></ul> <h2 id="读取值-和写入值"><a href="#读取值-和写入值" class="header-anchor">#</a> 读取值，和写入值</h2> <div class="language- extra-class"><pre class="language-text"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;vector&gt;


// 获取进程名的pid
DWORD getPID(const wchar_t* name)
{
	DWORD pid = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 pe;
		pe.dwSize = sizeof(pe);
		if (Process32First(hSnap, &amp;pe))
		{
			do {
				if (!_wcsicmp(pe.szExeFile, name)) {
					pid = pe.th32ProcessID;
					break;
				}
			} while (Process32Next(hSnap, &amp;pe));
		}
	}
	CloseHandle(hSnap);
	return pid;
}

// 获取模块基址
uintptr_t getModuleBaseAddress(DWORD pid, const wchar_t* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);

	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 me;
		me.dwSize = sizeof(me);
		if (Module32First(hSnap, &amp;me))
		{
			do {
				if (!_wcsicmp(me.szModule, modName)) {
					modBaseAddr = (uintptr_t)me.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &amp;me));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}

uintptr_t readIntger(HANDLE hProc, uintptr_t ptr, std::vector&lt;unsigned int&gt; offsets)
{
	uintptr_t addr = ptr;
	for (unsigned int i = 0; i &lt; offsets.size(); ++i)
	{
		// 进程句柄, 内存地址(从这里读), 值引用(存读取得值)，值的字节大小(读多大), null
		ReadProcessMemory(hProc, (BYTE*)addr, &amp;addr, sizeof(addr), 0);
		addr += offsets[i];
	}
	return addr;
}

int main()
{

	// 地址: [game.exe+009E820C]+338

	 // 1 获取进程pid
	DWORD pid = getPID(L&quot;game.exe&quot;);
	printf_s(&quot;pid: %d\n&quot;, pid);

	// 2 打开进程
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProcess == NULL) return 0; // 打开进程失败

	// 3 获取模块地址
	uintptr_t moduleBaseAddress = getModuleBaseAddress(pid, L&quot;game.exe&quot;);
	// 00905A4D
	printf_s(&quot;module address: %x\n&quot;, moduleBaseAddress);

	uintptr_t r = 0;
	ReadProcessMemory(hProcess, (LPCVOID)(moduleBaseAddress + 0x9E820C), &amp;r, sizeof(uintptr_t), 0);
	ReadProcessMemory(hProcess, (LPCVOID)(r + 0x338), &amp;r, 4, 0);
	printf_s(&quot;value: %d\n&quot;, r);


	// 写入新的值
	uintptr_t newValue = 20;
	ReadProcessMemory(hProcess, (LPCVOID)(moduleBaseAddress + 0x9E820C), &amp;r, sizeof(r), 0);
	WriteProcessMemory(hProcess, (LPVOID)(r + 0x338), (LPCVOID)&amp;newValue, sizeof(newValue), 0);

	CloseHandle(hProcess);
	return 0;
}
</code></pre></div><h2 id="类似ce的read-writeintger函数"><a href="#类似ce的read-writeintger函数" class="header-anchor">#</a> 类似CE的read/writeIntger函数</h2> <div class="language- extra-class"><pre class="language-text"><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;vector&gt;
#include &lt;regex&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

// global
DWORD pid = 0;
HANDLE hProcess = 0;

// 获取进程名的pid
DWORD getPID(const wchar_t* name)
{
	DWORD pid = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		PROCESSENTRY32 pe;
		pe.dwSize = sizeof(pe);
		if (Process32First(hSnap, &amp;pe))
		{
			do {
				if (!_wcsicmp(pe.szExeFile, name)) {
					pid = pe.th32ProcessID;
					break;
				}
			} while (Process32Next(hSnap, &amp;pe));
		}
	}
	CloseHandle(hSnap);
	return pid;
}

// 获取模块基址
uintptr_t getModuleBaseAddress(DWORD pid, const wchar_t* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);

	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 me;
		me.dwSize = sizeof(me);
		if (Module32First(hSnap, &amp;me))
		{
			do {
				if (!_wcsicmp(me.szModule, modName)) {
					modBaseAddr = (uintptr_t)me.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &amp;me));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}

std::string replaceString(std::string origenString, std::string replaceString, std::string newValue)
{
	int startIndex = origenString.find(replaceString);
	int endIndex = replaceString.size();
	return origenString.replace(startIndex - 1, endIndex + 2, newValue);
}

uintptr_t hexStr2Hex(std::string hexStr)
{
	uintptr_t r;
	std::stringstream(hexStr) &gt;&gt; std::hex &gt;&gt; r;
	return r;
}

struct SplitListItem
{
	std::string key;
	std::string value;
};

std::vector&lt;SplitListItem&gt; splitString(std::string origenString, std::regex pattern)
{
	std::smatch result;
	std::string::const_iterator iterStart = origenString.begin();
	std::string::const_iterator iterEnd = origenString.end();


	std::vector&lt;std::string&gt; splitList = {};
	std::vector&lt;std::string&gt; splitKeys = {};
	std::vector&lt;SplitListItem&gt; resultSplitList = {};

	while (regex_search(iterStart, iterEnd, result, pattern))
	{
		splitList.emplace_back(iterStart, result[0].first);
		splitKeys.push_back(result[0].str());
		iterStart = result[0].second;
	}
	splitList.emplace_back(iterStart, iterEnd);


	for (size_t i = 0; i &lt; splitList.size(); i++)
	{
		resultSplitList.push_back(SplitListItem{ i &gt; 0 ? splitKeys[i - 1] : &quot;&quot;,  splitList[i] });
	}
	return resultSplitList;
}

uintptr_t getOffsetsAddress(std::string address, uintptr_t nextValue = 0)
{
	
	std::string str = std::regex_replace(address, (std::regex)&quot;\\s&quot;, &quot;&quot;) ;
	std::smatch result;
	std::regex pattern(&quot;.*\\[([^\\[\\]]+)\\].*&quot;);
	std::regex_match(str, result, pattern);
	if (result.size() == 0)
	{
		if (str.size() == 0) {
			return nextValue;
		}

		std::vector&lt;SplitListItem&gt;  r = splitString(str, (std::regex)&quot;[+-]&quot;);

		uintptr_t a = hexStr2Hex(r[0].value);
		if (a == 0 &amp;&amp; r[0].value != &quot;0&quot;)
		{
			// 符号
			a = getModuleBaseAddress(
				pid,
				std::wstring(r[0].value.begin(), r[0].value.end()).c_str()
			);
		}
		uintptr_t b = hexStr2Hex(r[1].value);

		if (r[1].key == &quot;+&quot;) a += b;
		if (r[1].key == &quot;-&quot;) a -= b;
		return a;
	}



	std::vector&lt;SplitListItem&gt;  r = splitString(result[1], (std::regex)&quot;[+-]&quot;);
	uintptr_t data = 0;
	for (size_t i = 0; i &lt; r.size(); i++)
	{

		uintptr_t v = hexStr2Hex(r[i].value);

		if (v == 0 &amp;&amp; r[i].value != &quot;0&quot;)
		{
			// 符号
			data += getModuleBaseAddress(
				pid,
				std::wstring(r[i].value.begin(), r[i].value.end()).c_str()
			);
		}
		else
		{
			if (r[i].key == &quot;+&quot;) data += v;
			if (r[i].key == &quot;-&quot;) data -= v;
			ReadProcessMemory(hProcess, (LPCVOID)data, &amp;data, 4, 0);
		}
	}

	std::stringstream hexData;
	hexData &lt;&lt; std::hex &lt;&lt; data;
	std::string newOrigenString = replaceString(str, result[1], hexData.str());
	return getOffsetsAddress(newOrigenString, data);
}

uintptr_t readIntger(std::string address)
{
	uintptr_t r = getOffsetsAddress(address);
	if (r == 0) return 0;
	ReadProcessMemory(hProcess, (LPCVOID)r, &amp;r, 4, 0);
	return r;
}

uintptr_t writeIntger(std::string address, uintptr_t newInt)
{
	uintptr_t r = getOffsetsAddress(address);
	if (r == 0) return 0;
	WriteProcessMemory(hProcess, (LPVOID)r, (LPCVOID)&amp;newInt, 4, 0);
	return r;
}

int main()
{

	// 地址: [game.exe+009E820C]+338

	std::string mainname = &quot;game.exe&quot;;

	pid = getPID(std::wstring(mainname.begin(), mainname.end()).c_str());


	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProcess == NULL) return 0;


	std::cout &lt;&lt; readIntger(&quot;game.exe+009E820C&quot;) &lt;&lt; std::endl;
	std::cout &lt;&lt; readIntger(&quot;[game.exe + 009E820C] + 338&quot;) &lt;&lt; std::endl;

	writeIntger(&quot;[game.exe+ 009E820C] + 338&quot;, 20);
	

	CloseHandle(hProcess);
	return 0;
}
</code></pre></div><h2 id="dll"><a href="#dll" class="header-anchor">#</a> DLL</h2> <p>使用dll你可以向开发人员一样编写程序</p> <div class="language- extra-class"><pre class="language-text"><code>// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;vector&gt;
#include &lt;regex&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

// 获取模块基址
uintptr_t getModuleBaseAddress(const wchar_t* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, 0);

	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 me;
		me.dwSize = sizeof(me);
		if (Module32First(hSnap, &amp;me))
		{
			do {
				if (!_wcsicmp(me.szModule, modName)) {
					modBaseAddr = (uintptr_t)me.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &amp;me));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}

int Mythread(HMODULE hModule)
{
	// 创建控制台
	AllocConsole();
	FILE* f;
	freopen_s(&amp;f, &quot;CONOUT$&quot;, &quot;w&quot;, stdout);
	std::cout &lt;&lt; &quot;run...&quot;;

	uintptr_t miduleAddress = getModuleBaseAddress(L&quot;game.exe&quot;);
	std::cout &lt;&lt; &quot;miduleAddress: &quot; &lt;&lt; std::hex &lt;&lt; miduleAddress &lt;&lt; std::endl;

	// hack loop
	while (true)
	{
		// 按下f2，修改值
		if (GetAsyncKeyState(VK_F2) &amp; 1)
		{
			// [game.exe+009E820C]+338
			// addr = *(uintptr_t*)addr =&gt; mov addr [addr]

			// lea a, [miduleAddress + 0x009E820C]
			uintptr_t* a = (uintptr_t*)(miduleAddress + 0x009E820C);

			// mov eax, [miduleAddress + 0x009E820C]
			std::cout &lt;&lt; &quot;a value: &quot; &lt;&lt; std::hex &lt;&lt; *a &lt;&lt; std::endl;

			if (a)
			{
				std::cout &lt;&lt; &quot;old value: &quot; &lt;&lt; std::hex &lt;&lt; *(int*)(*a + 0x338) &lt;&lt; std::endl;
				// mov [eax+0x338], #10
				*(int*)(*a + 0x338) = 10; // 设置新值
			}
			break;
		}
		
		// 修改字节集
		if (GetAsyncKeyState(VK_F3) &amp; 1)
		{
			BYTE* address = (BYTE*)(miduleAddress + 0x3B79F7);

			// code: F3 0F 11 84 90 B8 02 00 00
			BYTE* bytes = (BYTE*)&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot;;
			int size = 9;

			// 保存旧的保护值
			DWORD oldprotect;

			// 要更改任何进程的访问保护
			VirtualProtect(address, size, PAGE_EXECUTE_READWRITE, &amp;oldprotect);
			
			// 从缓冲区复制字符
			// 设置新的，不同的字节集
			_memccpy(address, bytes, 0, size);

			// 将缓冲区设置为指定字符
			// 如果要设置相同的字节用这个方便点
			// memset(address, 0x90, size);

			VirtualProtect(address, size, oldprotect, &amp;oldprotect);
			break;
		}

		if (GetAsyncKeyState(VK_F12) &amp; 1)
		{
			// 释放资源
			fclose(f);
			FreeConsole();
			FreeLibraryAndExitThread(hModule, 0);
			break;
		}

		Sleep(5);
	}
	return 0;
}


BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mythread, hModule, 0, 0));
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
</code></pre></div><h2 id="aascript-to-c"><a href="#aascript-to-c" class="header-anchor">#</a> AAScript to c++</h2> <ul><li>https://www.youtube.com/watch?v=jTl3MFVKSUM</li></ul> <p>ce的aa脚本是一种绕行/挂钩技术</p> <p>源地址为<code>00433F86: mov [edi+00005578],esi</code>，将这里绕行到我们定义的函数，在最后jmp回去</p> <p>AAScript:</p> <div class="language- extra-class"><pre class="language-text"><code>[ENABLE]
aobscanmodule(INJECT,PlantsVsZombies.exe,89 B7 78 55 00 00)
alloc(newmem,$1000)

label(return)

newmem:
  add esi,#100
  mov [edi+00005578],esi
  jmp return

INJECT:
  jmp newmem
  nop
return:
registersymbol(INJECT)

[DISABLE]

INJECT:
  db 89 B7 78 55 00 00

unregistersymbol(INJECT)
dealloc(newmem)

{
00433F84: 2B F3                          -  sub esi,ebx
// ---------- INJECTING HERE ----------
00433F86: 89 B7 78 55 00 00              -  mov [edi+00005578],esi
// ---------- DONE INJECTING  ----------
00433F8C: B0 01                          -  mov al,01
}
</code></pre></div><p>cpp DLL:</p> <div class="language- extra-class"><pre class="language-text"><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;


bool handleHook(void * oldHook, void * newFunc, int len)
{
	if (len &lt; 5) return false;

	// 更改访问保护
	DWORD oldProc;
	VirtualProtect(oldHook, len, PAGE_EXECUTE_READWRITE, &amp;oldProc);

	// 先将旧的字节集设置为nop
	memset(oldHook, 0x90, len);

	// 计算新的字节集
	// 跳转目标地址 - 当前指令地址 - 5 = 字节集
	DWORD relativeAddress = ((DWORD)newFunc - (DWORD)oldHook - 5);
	
	// 设置jmp指令
	*(BYTE*)oldHook = 0xE9;
	*(DWORD*)((DWORD)oldHook + 1) = relativeAddress;
	
	// 修改后还原访问保护
	VirtualProtect(oldHook, len, oldProc, &amp;oldProc);

	return true;
}

DWORD returnAddress;

// 定义新的处理函数
void __declspec(naked) myNewFunc() {

	//newmem:
	__asm {
		add esi, 0x64
		mov[edi + 0x00005578], esi
		jmp [returnAddress]
	}
}

int Mythread(HMODULE hModule)
{
	DWORD oldHookAddress = 0x00433F86;
	int oldHookAddressLen = 6;

	// 0x433F8C
	returnAddress = oldHookAddress + oldHookAddressLen;
	handleHook((void*)oldHookAddress, myNewFunc, oldHookAddressLen);

	while (true)
	{
		if (GetAsyncKeyState((VK_F2))) break;
		Sleep(10);
	}

	// 脱钩
	FreeLibraryAndExitThread(hModule, 0);

	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mythread, hModule, 0, 0));
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
</code></pre></div><h2 id="module-scan"><a href="#module-scan" class="header-anchor">#</a> module scan</h2> <ul><li>https://www.youtube.com/watch?v=5M2rjjdX6DQ</li> <li>https://www.youtube.com/watch?v=S_SR5l_hquw</li></ul> <p>aa脚本：</p> <div class="language- extra-class"><pre class="language-text"><code>[ENABLE]

aobscanmodule(INJECT,game2.exe,A3 24 37 4B 00)
alloc(newmem,$1000)

label(code)
label(return)

newmem:
code:
  mov [004B3724],eax
  jmp return

INJECT:
  jmp newmem
return:
registersymbol(INJECT)

[DISABLE]

INJECT:
  db A3 24 37 4B 00

unregistersymbol(INJECT)
dealloc(newmem)

{
00401570: E8 97 FA FF FF        -  call game2.exe+100C
// ---------- INJECTING HERE ----------
00401575: A3 24 37 4B 00        -  mov [game2.exe+B3724],eax
// ---------- DONE INJECTING  ----------
0040157A: 68 01 03 00 80        -  push 80000301
}
</code></pre></div><p>c++</p> <div class="language- extra-class"><pre class="language-text"><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;Psapi.h&gt;


MODULEINFO GetModuleInfo(const wchar_t* mName)
{
	MODULEINFO mInfo = { 0 };
	HMODULE hModule = GetModuleHandleW(mName);
	if (hModule == 0) return mInfo;

	// 在MODULEINFO结构中检索有关指定模块的信息
	GetModuleInformation(GetCurrentProcess(), hModule, &amp;mInfo, sizeof(MODULEINFO));
	return mInfo;
}

DWORD ModuleScan(const wchar_t* moduleName, BYTE* bytes, const wchar_t* mask)
{
	// https://docs.microsoft.com/en-us/windows/win32/api/psapi/ns-psapi-moduleinfo
	MODULEINFO mInfo = GetModuleInfo(moduleName);

	// 起始位置
	uintptr_t base = (uintptr_t)mInfo.lpBaseOfDll;

	// 模块大小
	uintptr_t size = (uintptr_t)mInfo.SizeOfImage;

	int patternLen = wcslen(mask);
	wchar_t anyByte{ L'?' };

	for (size_t i = 0; i &lt; size - patternLen; i++)
	{
		bool found = true;
		for (size_t j = 0; j &lt; patternLen; j++)
		{
			found &amp;= mask[j] == anyByte || bytes[j] == *(BYTE*)(base + i + j);
		}
		
		// return find address start
		if (found) return base + i;
	}

	return 0;
}

int Mythread(HMODULE hModule)
{
	AllocConsole();
	FILE* f;
	freopen_s(&amp;f, &quot;CONOUT$&quot;, &quot;w&quot;, stdout);


	const wchar_t* moduleName = L&quot;game2.exe&quot;;
	BYTE* bytes = (BYTE*)&quot;\xA3\x24\x37\x4B\x00&quot;;
	// std::cout &lt;&lt; (bytes[0] == 0xA3) &lt;&lt; std::endl;
	const wchar_t* mask = L&quot;xxxxx&quot;; // 每一个代表一个字节?代表any

	DWORD address = ModuleScan(moduleName, bytes, mask);

	// 00401575
	std::cout &lt;&lt; std::hex &lt;&lt; address &lt;&lt; std::endl;

	while (true)
	{
		if (GetAsyncKeyState(VK_F12) &amp; 1)
		{
			break;
		}

		Sleep(10);
	}


	fclose(f);
	FreeConsole();
	// 脱钩
	FreeLibraryAndExitThread(hModule, 0);
	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mythread, hModule, 0, 0));
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
</code></pre></div><h2 id="c-调用游戏函数"><a href="#c-调用游戏函数" class="header-anchor">#</a> C++调用游戏函数</h2> <ul><li>https://www.youtube.com/watch?v=jmgwFpVnRmU</li> <li>https://www.youtube.com/watch?v=gZN2damgYHg</li> <li>https://www.youtube.com/watch?v=-hwUPT5Gyvc</li></ul> <h2 id="绕行挂钩技术-x86"><a href="#绕行挂钩技术-x86" class="header-anchor">#</a> 绕行挂钩技术 x86</h2> <div class="language- extra-class"><pre class="language-text"><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;

using namespace std;

uintptr_t GetModuleBaseAddr(const wchar_t* name)
{
	uintptr_t addr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, 0);

	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 me;
		me.dwSize = sizeof(me);
		if (Module32First(hSnap, &amp;me))
		{
			do
			{
				if (!_wcsicmp(me.szModule, name))
				{
					addr = (uintptr_t)me.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &amp;me));
		}
	}

	CloseHandle(hSnap);
	return addr;
}

uintptr_t returnAddr = 0;

void __declspec(naked) mymemnew()
{
	__asm {
		inc [esi]
		push edi
		mov edi, [esp + 0x14]
		jmp [returnAddr]
	}
}

int MyThread(HMODULE hModule)
{
	AllocConsole();
	FILE* f;
	freopen_s(&amp;f, &quot;CONOUT$&quot;, &quot;w&quot;, stdout);
	cout &lt;&lt; &quot;INJECT OK&quot; &lt;&lt; endl;

	// 1.获取模块地址
	// 2.创建钩子
	// 3.将源地址跳到钩子

	uintptr_t addr = GetModuleBaseAddr(L&quot;ac_client.exe&quot;);
	BYTE* address = (BYTE*)(addr + 0x637E9);
	BYTE bytes[] = { 0xFF, 0x0E, 0x57, 0x8B, 0x7C, 0x24, 0x14 };
	unsigned int size = sizeof(bytes);
	returnAddr = (uintptr_t)address + size;
	DWORD jmpBytes = (DWORD)mymemnew - (DWORD)address - 5;

	bool bEnable = false;
	while (true)
	{

		if (GetAsyncKeyState(VK_F2) &amp; 1)
		{
			bEnable = !bEnable;
			DWORD oldProc;
			VirtualProtect(address, size, PAGE_EXECUTE_READWRITE, &amp;oldProc);
			if (bEnable)
			{
				memset(address, 0x90, size);
				*(BYTE*)address = 0xE9;
				*(DWORD*)(address + 1) = jmpBytes;
			}
			else
			{
				_memccpy(address, bytes, 0, size);
			}
			VirtualProtect(address, size, oldProc, 0);
		}

		if( GetAsyncKeyState(VK_F12)&amp;1 )
		{
			break;
		}

		Sleep(20);
	}

	fclose(f);
	FreeConsole();
	FreeLibraryAndExitThread(hModule, 0);
	return 0;
}
</code></pre></div><h2 id="绕行挂钩技术-x64"><a href="#绕行挂钩技术-x64" class="header-anchor">#</a> 绕行挂钩技术 x64</h2> <div class="language- extra-class"><pre class="language-text"><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;Psapi.h&gt;

using namespace std;

MODULEINFO GetModuleInfo(const wchar_t* modname)
{
	MODULEINFO mi{ 0 };
	HMODULE hMod = GetModuleHandle(modname);
	GetModuleInformation(GetCurrentProcess(), hMod, &amp;mi, sizeof(mi));
	return mi;
}

int Mythread(HMODULE hModule)
{
	AllocConsole();
	FILE* f;
	freopen_s(&amp;f, &quot;CONOUT$&quot;, &quot;w&quot;, stdout);
	cout &lt;&lt; &quot;INJECT OK&quot; &lt;&lt; endl;

	// 获取模块信息
	MODULEINFO mi = GetModuleInfo(L&quot;MonsterHunterWorld.exe&quot;);

	// &quot;MonsterHunterWorld.exe&quot;+CE7462A
	BYTE* address = (BYTE*)((uintptr_t)mi.lpBaseOfDll + 0xCE7462A);
	BYTE bytes[] = {
		0xF3, 0x0F, 0x11, 0x41, 0x6C, // movss [rcx+6C],xmm0
	};
	int bytesSize = sizeof(bytes);

	// &quot;MonsterHunterWorld.exe&quot;+CE7462F
	uintptr_t returnAddr = (uintptr_t)address + bytesSize;


	/* newmem */
	BYTE codeBytes[] = {
		0xC7, 0x41, 0x6C, 0x00, 0x00, 0xC8, 0x42, // mov [rcx+6C],42C80000
	};
	int codeSize = sizeof(codeBytes);

	// 申请500字节虚拟空间存代码
	BYTE* newmem = (BYTE*)VirtualAlloc((BYTE*)((uintptr_t)mi.lpBaseOfDll - 0x10000)/* 2-4GB */, 500,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	/*
	BYTE* newmem2 = (BYTE*)VirtualAlloc((BYTE*)((uintptr_t)newmem - 0x10000), 4,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	*/


	// 将代码复制到newmem
	memcpy_s(newmem, codeSize, codeBytes, codeSize);

	// jmp return
	uintptr_t newmemJmpReturnAddr = ((uintptr_t)newmem + codeSize);

	// 计算jmp字节集，丢弃高位
	DWORD returnBytes = (DWORD)(returnAddr - newmemJmpReturnAddr - 5);

	// jmp &quot;MonsterHunterWorld.exe&quot;+CE7462F
	*(BYTE*)(newmemJmpReturnAddr) = 0xE9; // jmp
	*(DWORD*)(newmemJmpReturnAddr + 1) = returnBytes; // 
	/* newmem */

	DWORD jmpNewmemBytes = (DWORD)((uintptr_t)newmem - (uintptr_t)address - 5);
	bool bEnable = false;
	while (true)
	{
		if (GetAsyncKeyState(VK_F2) &amp; 1)
		{
			bEnable = !bEnable;
			DWORD oldProc;
			VirtualProtect(address, bytesSize, PAGE_EXECUTE_READWRITE, &amp;oldProc);
			if (bEnable)
			{
				cout &lt;&lt; &quot;[ENABLE]&quot; &lt;&lt; endl;
				memset(address, 0x90, bytesSize);

				// jmp newmem
				*(BYTE*)(address) = 0xE9; // jmp
				*(DWORD*)(address + 1) = jmpNewmemBytes;
			}
			else
			{
				cout &lt;&lt; &quot;[DISABLE]&quot; &lt;&lt; endl;
				memcpy_s(address, bytesSize, bytes, bytesSize);
			}
			VirtualProtect(address, bytesSize, oldProc, 0);
		}

		if (GetAsyncKeyState(VK_F12) &amp; 1)
		{
			break;
		}
		Sleep(20);
	}
	
	VirtualFree(newmem, 0, MEM_RELEASE);
	fclose(f);
	FreeConsole();
	FreeLibraryAndExitThread(hModule, 0);
	return 0;
}
</code></pre></div><h2 id="钩住opengl32-dll-wglswapbuffers函数头"><a href="#钩住opengl32-dll-wglswapbuffers函数头" class="header-anchor">#</a> 钩住opengl32.dll-&gt;wglSwapBuffers函数头</h2> <ul><li>https://guidedhacking.com/threads/how-to-hook-functions-code-detouring-guide.14185/</li></ul> <div class="language- extra-class"><pre class="language-text"><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
#include &lt;TlHelp32.h&gt;

using namespace std;

typedef BOOL(__stdcall* mywglSwapBuffers)(HDC hDc);
mywglSwapBuffers  owglSwapBuffers;

HMODULE _hModule = 0;
FILE* _f;


// 定义自己的钩子函数
BOOL __stdcall mywglSwapBuffersHook(HDC hDc)
{
		if (GetAsyncKeyState(VK_F2) &amp; 1)
		{
			cout &lt;&lt; &quot;F2&quot; &lt;&lt; endl;
		}

		/* 脱钩失败
		if (GetAsyncKeyState(VK_F12) &amp; 1)
		{
			fclose(_f);
			FreeConsole();
			FreeLibraryAndExitThread(_hModule, 0);
		}
		*/
	return owglSwapBuffers(hDc);
}

uintptr_t GetModuleBaseAddress(const wchar_t* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, 0);

	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 me;
		me.dwSize = sizeof(me);
		if (Module32First(hSnap, &amp;me))
		{
			do {
				if (!_wcsicmp(me.szModule, modName)) {
					modBaseAddr = (uintptr_t)me.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &amp;me));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}


/* 钩住wglSwapBuffers */
bool Detour32(BYTE* origen, BYTE* hook, int len)
{
	if (len &lt; 5) return false;
	DWORD oldProc;
	VirtualProtect(origen, len, PAGE_EXECUTE_READWRITE, &amp;oldProc);
	
	// 将wglSwapBuffers函数开始处设置为
	// jmp mywglSwapBuffersHook
	uintptr_t jmpHookBytes =  hook - origen - 5;
	*origen = 0xE9;
	*(uintptr_t*)(origen + 1) = jmpHookBytes;

	VirtualProtect(origen, len, oldProc, 0);
}

BYTE* TrampHook32(BYTE* origen, BYTE* hook, int len)
{
	if (len &lt; 5) return 0;

	// 申请一块虚拟内存存代码
	BYTE* gateway = (BYTE*)VirtualAlloc(0, len, 
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	// 从origen中拷贝len大小的字节到gateway
	_memccpy(gateway, origen, 0, len);

	// jmp wglSwapBuffers+5
	// uintptr_t returnBytes = (origen+len) - (gateway+len) - 5;
	uintptr_t returnBytes = origen - gateway - 5;
	*(gateway + len) = 0xE9;
	*(uintptr_t*)((uintptr_t)gateway + len + 1) = returnBytes;

	Detour32(origen, hook, len);

	return gateway;
}

int Mythread()
{
	AllocConsole();
	freopen_s(&amp;_f, &quot;CONOUT$&quot;, &quot;w&quot;, stdout);
	cout &lt;&lt; &quot;INJECT OK&quot; &lt;&lt; endl;

	// 显示连接DLL函数
	// opengl32.dll导出的wglSwapBuffers函数
	owglSwapBuffers = (mywglSwapBuffers)GetProcAddress(
		GetModuleHandleW(L&quot;opengl32.dll&quot;), &quot;wglSwapBuffers&quot;);

	// 将返回的虚拟内存地址给owglSwapBuffers
	// 在mywglSwapBuffersHook中的owglSwapBuffers将执行
	owglSwapBuffers = (mywglSwapBuffers)TrampHook32(
		(BYTE*)owglSwapBuffers, (BYTE*)mywglSwapBuffersHook, 5);
	return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		_hModule = hModule;
		CloseHandle(CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Mythread, 0, 0, 0));
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/game-reversed-study/AAScript/自定义符号.html" class="prev">
        自定义符号
      </a></span> <span class="next"><a href="/game-reversed-study/cpp-hack/inject/普通的线程注入.html">
        普通的线程注入
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/game-reversed-study/assets/js/app.7795f1ac.js" defer></script><script src="/game-reversed-study/assets/js/2.def8a94b.js" defer></script><script src="/game-reversed-study/assets/js/23.0e54e1fa.js" defer></script>
  </body>
</html>
